
---

感謝 **Winner, Brinton** 幫忙驗題
  
感謝 **tobiichi3227** 給予各方面幫助
  
感謝各位參賽者們認真努力不懈的參加比賽

---

<div style="page-break-after: always"></div>

# 巧克力戰爭 (chocolate)
題目靈感 : [JOISC 2025 day1 pB](https://atcoder.jp/contests/joisp2025/tasks/joisp2025_b)

看到長度要 $\log_2 n$ 應該要能想到 'B' 當 1, 'W' 當 0 用二進位來表達 b，但這樣就會遇到 'W' 不夠的問題，可以證明 'B' 不會不夠。

'W' 不夠代表 n - b 很小，那我們就把 n - b 個 'W' 全部放出來就好，Bla 知道 n 所以就可以得出 b 了。

---

Brinton 說可以出到 $\lfloor \log_2 N \rfloor$ (原本是 $\lceil \log_2 N \rceil$ )  

我是不會做，可以去問他要怎麼寫。



<div style="page-break-after: always"></div>

# 桌遊 (game)
題目靈感 : [cses 1157](https://cses.fi/problemset/task/1157)，[我資訊課做的破專案](https://docs.google.com/presentation/d/1t11bme0r7fQr4DMLYNSmYeY4zH3Q53FbyAE3ufJXIEM/edit?usp=sharing)

相信大家都會基本的賽局 DP，所以前三個子任務暴力打個 win state, lose state 就能得出來了。

接著你就能觀察出，這個遊戲 x 和 y 兩個維度可以分開來看，也就是這個遊戲可以等價換成，有兩堆石頭，一堆有 x - 1 顆，一堆有 y - 1 顆，我們可以選擇其中一堆拿走給定數量的石頭，不能操作就輸了。

這顯然是個經典問題，我們砸個 Sprague-Grundy theorem 就好了。  

---

應該有人沒聽過這東西，簡單說一下。

沒有限制拿的數量的 nim game 大家應該都會玩，考慮有限制拿的數量的nim game

假設我們可以選擇拿 $b_1, b_2, …, b_m$ 顆石頭，我們把有限制拿的數量的一堆有 k 顆石頭，等價映射到沒有限制拿的數量的一堆有 sg[k] 顆石頭，其中 sg[k] = $$mex(sg[k - b_1], sg[k - b_2], …, sg[k - b_m])$$

其中 mex 是 "minimum excluded value" 也就是這個集合中最小沒有出現的非負整數

這樣我們就可以用 sg[k] 假裝我們在玩沒有限制拿的數量的 nim game 了。  
因為定義的關係，我們從 sg[k] 拿任意數量的石頭都可以對應到原本遊戲的其中一種操作。

舉個例子，假設能拿 1, 3, 4 顆

| k     | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   | 10  |
| ----- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| sg[k] | 0   | 1   | 0   | 1   | 2   | 3   | 2   | 0   | 1   | 0   | 1   |

像是 k = 4，他經過操作後可能會變成 0, 1, 3 顆，所以 sg[4] = mex(sg[0], sg[1], sg[3]) = mex(0, 1, 1) = 2

所以在有限制下一堆有 4 顆，相當於無限制下一堆有 2 顆，我們在有限制下 4 顆變 1 顆或 3 顆的操作都相當於無限制下 2 顆變 1 顆，4 顆變 0 顆的操作相當於無限制下 2 顆變 0 顆。

<div style="page-break-after: always"></div>


# NBC(nbc)

題目靈感 : [JOISC 2025 day 3 pC](https://atcoder.jp/contests/joigsp2025/tasks/joigsp2025_g)，IOIC 2025 非典型例題


題序告訴我們要壓到 $\log_2 n$ 次才會拿到滿分，想到 $\log_2$ 又觀察到有一半的測資是 $2^k$ 你當然就會想到二進位。  
你又會觀察到一個理所當然的事實，若 $i, j$ 不同，則他們二進位下至少一個 bit 不同。  
有了這些觀察，答案就呼之欲出了，我們可以對每個數的二進位一個一個 bit 看，如果他的第 i 個 bit 是 0 就讓他第 i 場去左邊，是 1 就讓他第 i 場去右邊。

寫下去就會發現，這只有在 $n = 2^k$ 下的 case 會對，因為題目有要要求每場必須左右人數相同，這樣 n 不是 $2^k$ 下可能會有某個 bit 0 比較多 1 比較少之類的狀況。

為了解決這個問題，我們可以對每個數字重新做編號:  
對於偶數，他的編號保持不變。  
對於奇數，把他編號為他原本的二進位 -1 後取 not。  

舉例來說 n = 10
```
0000 -> 0000        0001 -> 1111
0010 -> 0010        0011 -> 1101
0100 -> 0100        0101 -> 1011
0110 -> 0110        0111 -> 1001
1000 -> 1000        1001 -> 0111
```
如此一來，對於每一場比賽， a 和 a ^ 1 (^ 是 bitwise xor) 一定在不同隊，這保證每一隊的人數都會相同，而且可以證明新的二進位編號不會重複，也就是任兩個不同的數，他們也一定有一個 bit 不同。

以上是 2025 IOI 國手 brinton 的解，我覺得特別漂亮所以把它拿來當官解。  

---

原本的官解 :  

我們把二進位想法丟掉重新想，想到 $\log_2$ 當然還會想到線段樹，所以我們考慮一顆 $0$ ~ $n - 1$ 的線段樹。

考慮通靈，我們可以把一個數如果落在第 $i$ 層的左子節點我們就讓他去左邊，反之就去右邊。

這樣，$i, j$ 不同，他們就會在他們線段樹上 lca 的下面那層分開來。

但是這樣還是沒解決人數會不一樣的問題，線段樹上第 i 層可能左子節點還是會比右子節點多。

我們把線段樹畫出來觀察一下，如果拔掉第一層，分裂出來的兩個子樹會是完全同構的，我們稱為左樹和右樹。

我們換個分隊方法，同一層中，只要把左樹的左子節點和右樹的右子節點設為同一隊，右樹的左子節點及左樹的右子節點設為同一隊，這樣兩隊就會一樣多人了，而且在 lca 下面那層還是會分開來。

<div style="page-break-after: always"></div>

# 簡短的問題 (short)
題目靈感 : IOIC 2024 講義隨機例題

簽到題，應該有一千萬種作法，像是 std::rotate 就可以符合條件了。
